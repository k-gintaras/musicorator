{"ast":null,"code":"import { PopupComponent } from './popup/popup.component';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material/dialog\";\nimport * as i2 from \"@angular/material/snack-bar\";\nexport let HelperService = /*#__PURE__*/(() => {\n  class HelperService {\n    constructor(dialog, snackBar) {\n      this.dialog = dialog;\n      this.snackBar = snackBar;\n    }\n    feedback(s) {\n      this.snackBar.open(s, 'Close', {\n        duration: 3000\n      });\n    }\n    getCsvFromMatrix(m) {\n      if (m) {\n        if (m.length > 0) {\n          if (m[0][0]) {\n            const all = [];\n            for (const row of m) {\n              all.push(row.join(','));\n            }\n            return all.join('\\n') + '\\n';\n          }\n        }\n      }\n      return '';\n    }\n    tryAddValidatedSimilar(valIn, arr, isRemoveNonUnique, toLowerCase, reasonableWordLength) {\n      if (toLowerCase) {\n        valIn = valIn.toLowerCase();\n      }\n      // add only if part does not exist\n      let canAdd = true;\n      for (let i = 0; i < arr.length; i++) {\n        const val = arr[i];\n        // reasonable word\n        if (valIn.length >= reasonableWordLength) {\n          // its part is in array,  oldest <<< [old,,,]\n          if (valIn.indexOf(val) > -1) {\n            arr[i] = valIn;\n            canAdd = false;\n            break;\n          }\n        } else {\n          canAdd = false;\n        }\n      }\n      if (canAdd) {\n        this.tryAddValidated(valIn, arr, isRemoveNonUnique, toLowerCase);\n      }\n    }\n    tryAddValidated(value, arr, isRemoveNonUnique, toLowerCase) {\n      if (toLowerCase) {\n        value = value.toLowerCase();\n      }\n      const name = value;\n      const unique = this.isNotIn(name, arr);\n      if (unique) {\n        if ((name || '').trim()) {\n          let clean = name.trim();\n          if (toLowerCase) {\n            clean = clean.toLowerCase();\n          }\n          arr.push(clean);\n        }\n      } else {\n        if (isRemoveNonUnique) {\n          this.removeFromArr(name, arr);\n        }\n      }\n    }\n    removeFromArr(tag, arr) {\n      const index = arr.indexOf(tag);\n      if (index > -1) {\n        arr.splice(index, 1);\n      }\n    }\n    getOnlyUnique(arr) {\n      // don't use empty\n      arr = arr.filter(res => {\n        if (res) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n      return arr.filter((value, index, self) => {\n        return self.indexOf(value) === index;\n      });\n    }\n    getParsedIntSimple(x, badReturn) {\n      const base = 10;\n      const parsed = parseInt(x, base);\n      if (isNaN(parsed)) {\n        return badReturn;\n      }\n      return parsed;\n    }\n    getParsedInt(x, base, badReturn) {\n      const parsed = parseInt(x, base);\n      if (isNaN(parsed)) {\n        return badReturn;\n      }\n      return parsed;\n    }\n    displayPopup(array) {\n      const dialogRef = this.dialog.open(PopupComponent);\n      dialogRef.afterClosed().subscribe(result => {\n        this.feedback('Replied: ' + result);\n      });\n    }\n    sortArrayByLength(arr) {\n      arr.sort((a, b) => {\n        // ASC  -> a.length - b.length\n        // DESC -> b.length - a.length\n        return a.length - b.length;\n      });\n    }\n    getTrimmedArray(arr) {\n      return arr.map(str => str.trim());\n    }\n    getLowerCaseArray(arr) {\n      return arr.map(str => str.toLowerCase());\n    }\n    isInArray(value, array) {\n      return array.indexOf(value) > -1;\n    }\n    getObjectFromKeys(obj, keys) {\n      const ret = {};\n      for (const key of keys) {\n        if (obj[key]) {\n          ret[key] = obj[key];\n        }\n      }\n      return ret;\n    }\n    removeFromArray(item, arr) {\n      const index = arr.indexOf(item);\n      if (index >= 0) {\n        arr.splice(index, 1);\n      }\n    }\n    addUniqueToArray(value, arr) {\n      const unique = this.isNotIn(value, arr);\n      if (unique) {\n        if (value) {\n          arr.push(value);\n        }\n      }\n    }\n    // only add if unique\n    isNotIn(val, arr) {\n      return !(arr.indexOf(val) > -1);\n    }\n    getValuesFromKeys(obj, keys) {\n      const ret = [];\n      for (const key of keys) {\n        if (obj[key]) {\n          ret.push(obj[key]);\n        }\n      }\n      return ret;\n    }\n    // it's all thanks to\n    // https://stackoverflow.com/questions/4810841/pretty-print-json-using-javascript\n    getPrettyCode(json) {\n      if (typeof json !== 'string') {\n        json = JSON.stringify(json, undefined, 2);\n      }\n      json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      return json.replace(/(\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\"])*\"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)/g, match => {\n        let cls = 'number';\n        if (/^\"/.test(match)) {\n          if (/:$/.test(match)) {\n            cls = 'key';\n          } else {\n            cls = 'string';\n          }\n        } else if (/true|false/.test(match)) {\n          cls = 'boolean';\n        } else if (/null/.test(match)) {\n          cls = 'null';\n        }\n        return '<span class=\"' + cls + '\">' + match + '</span>';\n      });\n      // add css\n      // pre {outline: 1px solid #ccc; padding: 5px; margin: 5px; }\n      // .string { color: green; }\n      // .number { color: darkorange; }\n      // .boolean { color: blue; }\n      // .null { color: magenta; }\n      // .key { color: red; }\n    }\n\n    getArrayCopy(arr) {\n      return Object.assign([], arr);\n    }\n    /**\n     *\n     * https://stackoverflow.com/questions/14446511/most-efficient-method-to-groupby-on-an-array-of-objects\n     * @description\n     * Takes an Array<V>, and a grouping function,\n     * and returns a Map of the array grouped by the grouping function.\n     *\n     * @param list An array of type V.\n     * @param keyGetter A Function that takes the the Array type V as an input, and returns a value of type K.\n     *                  K is generally intended to be a property key of V.\n     *\n     * @returns Map of the array grouped by the grouping function.\n     */\n    // export function groupBy<K, V>(list: Array<V>, keyGetter: (input: V) => K): Map<K, Array<V>> {\n    //    const map = new Map<K, Array<V>>();\n    groupBy(list, keyGetter) {\n      const map = new Map();\n      list.forEach(item => {\n        const key = keyGetter(item);\n        const collection = map.get(key);\n        if (!collection) {\n          map.set(key, [item]);\n        } else {\n          collection.push(item);\n        }\n      });\n      return map;\n    }\n    static #_ = this.ɵfac = function HelperService_Factory(t) {\n      return new (t || HelperService)(i0.ɵɵinject(i1.MatDialog), i0.ɵɵinject(i2.MatSnackBar));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: HelperService,\n      factory: HelperService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HelperService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}