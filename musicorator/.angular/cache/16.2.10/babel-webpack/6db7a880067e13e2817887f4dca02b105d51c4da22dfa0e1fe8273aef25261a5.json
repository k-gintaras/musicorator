{"ast":null,"code":"import { BehaviorSubject, Observable } from 'rxjs';\nimport { ValidRequest } from './ValidRequest';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./helper.service\";\nimport * as i2 from \"./test-data.service\";\nimport * as i3 from \"./tagging-from-file/suggestion.service\";\n// const ipc = (window as any).require('electron').ipcRenderer;\nexport let ElectronCommunicatorService = /*#__PURE__*/(() => {\n  class ElectronCommunicatorService {\n    constructor(zone, helper, t, suggestionService) {\n      this.zone = zone;\n      this.helper = helper;\n      this.t = t;\n      this.suggestionService = suggestionService;\n      // these needed to simulate data if you just use ng serve\n      this.electronReceiveSimulatorSubject = new BehaviorSubject('');\n      this.electronReceiveSimulatorObservable = this.electronReceiveSimulatorSubject.asObservable();\n      this.electronSendSimulatorSubject = new BehaviorSubject('');\n      this.electronSendSimulatorObservable = this.electronSendSimulatorSubject.asObservable();\n      if (window.require) {\n        try {\n          this.ipc = window.require('electron').ipcRenderer;\n        } catch (error) {\n          console.log(error);\n        }\n      } else {\n        console.log('Could not load electron ipc');\n      }\n    }\n    sendToElectron(options) {\n      if (this.ipc) {\n        this.sendElectron(options);\n      } else {\n        this.sendAngular(options);\n      }\n    }\n    // sendToElectron(key: string, parameters: any[]): void {\n    //   if (this.ipc) {\n    //     this.sendElectron(key, parameters);\n    //   } else {\n    //     this.sendAngular(key, parameters);\n    //   }\n    // }\n    listenToElectronConstantly(key) {\n      if (this.ipc) {\n        return this.listenElectron(key);\n      } else {\n        return this.listenAngular(key);\n      }\n    }\n    /**\n     * responseFromMain\n     * {key: string, response: any}\n     */\n    listenToElectronResponsibly(key) {\n      if (this.ipc) {\n        return this.listenElectronResponsibly(key);\n      } else {\n        return this.listenAngularResponsibly();\n      }\n    }\n    sendElectron(options) {\n      this.ipc.send('requestFromRenderer', options);\n    }\n    // TODO: you can try this, but this creates lots of listeners and gets memory leak warning\n    // sendElectron(key: string, options: {}): void {\n    //   this.ipc.send(key, options);\n    // }\n    sendAngular(options) {\n      console.log('sending to electron: ' + options.key);\n      this.electronSendSimulatorSubject.next(options);\n    }\n    listenElectron(key) {\n      const observable = new Observable(subscriber => {\n        try {\n          this.ipc.on(key, (event, arg) => {\n            this.zone.run(() => {\n              subscriber.next(arg);\n              // subscriber.complete(); if you want to stop from listening next values\n            });\n          });\n        } catch (error) {\n          this.feedback('Electron Communicator Error: ' + error);\n          subscriber.next('listenToElectronConstantly() Error: ' + key);\n          subscriber.complete();\n        }\n      });\n      return observable;\n    }\n    /**\n     * responseFromMain\n     * {key: string, response: any}\n     */\n    listenElectronResponsibly(key) {\n      this.mainResponseObservable = new Observable(subscriber => {\n        try {\n          this.ipc.on(key, (event, arg) => {\n            this.zone.run(() => {\n              subscriber.next(arg);\n              // subscriber.complete(); if you want to stop from listening next values\n            });\n          });\n        } catch (error) {\n          this.feedback('Electron Communicator Error: ' + error);\n          subscriber.next('listenElectronResponsibly() Error: ' + key);\n          subscriber.complete();\n        }\n      });\n      return this.mainResponseObservable;\n    }\n    /**\n     * responseFromMain to use onDestroy in addition to unsubscribe\n     */\n    unsubscribeElectron() {\n      if (this.mainResponseObservable) {\n        this.ipc.removeListener('responseFromMain', this.mainResponseObservable);\n      }\n    }\n    listenAngular(key) {\n      const responseObject = {\n        key: 'testResponseOne',\n        response: JSON.parse(this.suggestionService.suggestionsJson)\n      };\n      const observable = new Observable(subscriber => {\n        try {\n          switch (key) {\n            case 'getFilesByType':\n              subscriber.next(this.t.getTestFolders());\n              break;\n            case 'getAllMusicData':\n              subscriber.next(this.t.getTestData());\n              break;\n            case 'getMusicData':\n              subscriber.next(this.t.getTestData()[0].data);\n              break;\n            case 'getSettings':\n              subscriber.next(JSON.parse(this.suggestionService.suggestionsJson));\n              break;\n            case 'getTestResponseSettingsOne':\n              subscriber.next(responseObject);\n              break;\n            case ValidRequest.openDirectory:\n              subscriber.next('C:/Users');\n              break;\n            default:\n              break;\n          }\n        } catch (error) {\n          this.feedback('Electron Communicator Error: ' + error);\n          subscriber.next('listenToElectronConstantly Error: ' + key);\n          subscriber.complete();\n        }\n      });\n      return observable;\n    }\n    listenAngularResponsibly() {\n      this.electronSendSimulatorObservable.subscribe(response => {\n        console.log('Received Request From Angular: ');\n        console.log(response);\n        this.handleSimulatedResponse(response);\n      });\n      return this.electronReceiveSimulatorObservable;\n    }\n    handleSimulatedResponse(r) {\n      const key = r.key;\n      const data = r.response;\n      const responseObject = {\n        key: 'testResponseOne',\n        response: JSON.parse(this.suggestionService.suggestionsJson)\n      };\n      try {\n        switch (key) {\n          case 'getFilesByType':\n            this.electronReceiveSimulatorSubject.next(this.t.getTestFolders());\n            break;\n          case 'getAllMusicData':\n            this.electronReceiveSimulatorSubject.next(this.t.getTestData());\n            break;\n          case 'getMusicData':\n            this.electronReceiveSimulatorSubject.next(this.t.getTestData()[0].data);\n            break;\n          case 'getSettings':\n            this.electronReceiveSimulatorSubject.next(JSON.parse(this.suggestionService.suggestionsJson));\n            break;\n          case 'getTestResponseSettingsOne':\n            this.electronReceiveSimulatorSubject.next(responseObject);\n            break;\n          case ValidRequest.openDirectory:\n            console.log('Replying to: ' + ValidRequest.openDirectory);\n            responseObject.key = ValidRequest.openDirectory;\n            responseObject.response = 'C:/Users';\n            this.electronReceiveSimulatorSubject.next(responseObject);\n            break;\n          default:\n            break;\n        }\n      } catch (error) {\n        this.feedback('Electron Communicator Error: ' + error);\n        this.electronReceiveSimulatorSubject.next('listenToElectronConstantly Error: ' + key);\n        this.electronReceiveSimulatorSubject.complete();\n      }\n    }\n    getFileName(dir) {\n      if (dir) {\n        return dir.replace(/^.*[\\\\\\/]/, '');\n      }\n      return dir;\n    }\n    feedback(s) {\n      this.helper.feedback(s);\n    }\n    static #_ = this.ɵfac = function ElectronCommunicatorService_Factory(t) {\n      return new (t || ElectronCommunicatorService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.HelperService), i0.ɵɵinject(i2.TestDataService), i0.ɵɵinject(i3.SuggestionService));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ElectronCommunicatorService,\n      factory: ElectronCommunicatorService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ElectronCommunicatorService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}