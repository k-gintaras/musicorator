{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport { ValidRequest } from './ValidRequest';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./popup/popup.service\";\nimport * as i2 from \"./helper.service\";\nimport * as i3 from \"./communicator-electron.service\";\nexport let DataProcessorService = /*#__PURE__*/(() => {\n  class DataProcessorService {\n    constructor(dialog, helper, communicator) {\n      this.dialog = dialog;\n      this.helper = helper;\n      this.communicator = communicator;\n      // feedback\n      this.isLoading = false;\n      this.progress = 100;\n      this.feedbackCounter = 0;\n      this.maxFeedbackLimit = 0;\n      this.feedbackSubject = new BehaviorSubject('');\n      this.feedbackObservable = this.feedbackSubject.asObservable();\n      this.progressSubject = new BehaviorSubject(0);\n      this.progressObservable = this.progressSubject.asObservable();\n      // in case there is need to send some messages\n      this.commonMessageSubject = new BehaviorSubject('');\n      this.commonMessageObservable = this.commonMessageSubject.asObservable();\n      // audio metadata\n      this.metadataKeys = ['title', 'album', 'artist', 'composer', 'bpm', 'initialKey'];\n      // filter\n      this.searchStringsArray = [{\n        column: 'title',\n        search: ''\n      }, {\n        column: 'artist',\n        search: ''\n      }, {\n        column: 'album',\n        search: ''\n      }, {\n        column: 'composer',\n        search: ''\n      }, {\n        column: 'genre',\n        search: ''\n      }, {\n        column: 'year',\n        search: ''\n      }, {\n        column: 'bpm',\n        search: ''\n      }, {\n        column: 'initialKey',\n        search: ''\n      }, {\n        column: 'tags',\n        search: ''\n      }];\n      this.TABLE_EXTRA_VALUE_SPLITTER = ' ';\n    }\n    getMusicDataResult() {\n      return this.musicDataResult;\n    }\n    setMusicDataResult(result) {\n      this.musicDataResult = result;\n    }\n    getFilteredMatrix(matrixIn, columnNames, searchStringsArray, isLessThan) {\n      return matrixIn.filter(item => {\n        const matches = [];\n        for (const val of searchStringsArray) {\n          const searchColumn = val.column;\n          const b = val.search;\n          if (b) {\n            const pos = columnNames.indexOf(searchColumn);\n            // match only if matches all from search\n            if (pos > -1) {\n              const a = item[pos];\n              const match = this.isMatch(a, b, isLessThan);\n              matches.push(match);\n              // return match;\n              // if (a && a.indexOf(',') > -1) {\n              //   const tags = b.split(',');\n              //   for (const tag of tags) {\n              //     const matchTag = this.isMatch(a, tag, isLessThan);\n              //     if (!matchTag) {\n              //       return false;\n              //     }\n              //   }\n              // } else {\n              //   if (!match) {\n              //     return false;\n              //   }\n              // }\n            }\n          }\n        }\n        // not all match, therefore not all filter passed\n        for (const val of matches) {\n          if (!val) {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n    // TODO: filter matrix useful\n    // setFilter(): void {\n    //   this.matrixOut = this.matrixIn.filter((item) => {\n    //     for (let i = 0; i < this.searchStringsArray.length; i++) {\n    //       const val = this.searchStringsArray[i];\n    //       const searchColumn = val.column;\n    //       const b = val.search;\n    //       if (b) {\n    //         const a = item[i];\n    //         const match = this.isMatch(a, b);\n    //         if (b.split(' ') > 0) {\n    //           if (a) {\n    //             const tags = b.split(' ');\n    //             for (const tag of tags) {\n    //               const matchTag = this.isMatch(a, tag);\n    //               if (!matchTag) {\n    //                 return false;\n    //               }\n    //             }\n    //           }\n    //         } else {\n    //           if (!match) {\n    //             return false;\n    //           }\n    //         }\n    //       }\n    //     }\n    //     return true;\n    //   });\n    //   this.onSearchFilter();\n    //   this.onDataChange();\n    // }\n    loadAllMusicFiles(foldersIn, feedback) {\n      this.setMaxForFeedback(foldersIn.length);\n      this.sendElectron(ValidRequest.getAllMusicData, {\n        folders: foldersIn\n      });\n      const msg = 'Loading Files...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    makeDir(whereIn, nameIn, feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.createFolder, {\n        folder: whereIn,\n        name: nameIn\n      });\n      const msg = 'Creating Directory...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    copyDirectory(folderIn, nameIn, foldersIn, feedback) {\n      this.setMaxForFeedback(foldersIn.length);\n      this.sendElectron(ValidRequest.copyAllFiles, {\n        folder: folderIn,\n        name: nameIn,\n        folders: foldersIn\n      });\n      const msg = 'Copying Directory...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    openFolder(feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.openDirectory, {});\n      const msg = 'Opening Folder...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    loadSettings(feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.getSettings, {});\n      const msg = 'Getting Settings...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    playSong(file, feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.playAudio, {\n        dir: file\n      });\n      const msg = 'Playing Audio...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    playPlaylist(files, feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.playPlaylist, {\n        dir: files\n      });\n      const msg = 'Playing Playlist...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    getFilesByType(file, fileContains, feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.getFilesByType, {\n        dir: file,\n        type: fileContains\n      });\n      const msg = 'Getting Files...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    getSongData(file, feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.getMusicData, {\n        dir: file\n      });\n      const msg = 'Getting Audio Data...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    saveSongData(file, tags, feedback) {\n      this.setMaxForFeedback(0);\n      this.sendElectron(ValidRequest.setMusicData, {\n        dir: file,\n        tagsObject: this.getTagsFormatted(tags)\n      });\n      const msg = 'Saving Audio Data...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    saveSettings(settingsObject, tagsJson, feedback) {\n      this.setMaxForFeedback(0);\n      settingsObject.tags = tagsJson;\n      this.sendElectron(ValidRequest.saveSettings, {\n        data: settingsObject\n      });\n      const msg = 'Saving Settings...';\n      if (feedback) {\n        feedback(msg);\n      }\n    }\n    getTagsFormatted(arr) {\n      if (arr) {\n        if (arr.length > 0) {\n          const trimedArr = arr.map(str => str.trim().toLowerCase());\n          const tagString = trimedArr.join(',');\n          const updatedComment = {\n            language: 'eng',\n            shortText: '',\n            text: tagString\n          };\n          // library requires top object // I didn't realize and ruined some files :D\n          // update just edits tags added, write overwrites and deletes the rest\n          const tags = {\n            COMM: updatedComment,\n            comment: updatedComment\n          };\n          return tags;\n        }\n      }\n      return '';\n    }\n    sendElectron(keyIn, options) {\n      options.key = keyIn;\n      this.communicator.sendToElectron(options);\n    }\n    getSortableObjects(result) {\n      const sortableObjects = [];\n      for (const electronObject of result) {\n        const o = this.getMusicSortableObject(electronObject);\n        sortableObjects.push(o);\n      }\n      return sortableObjects;\n    }\n    getMusicSortableObject(o) {\n      const file = o.file;\n      const data = o.data;\n      const emptyString = 'empty';\n      const emptyNumber = 0;\n      let validatedTags = emptyString;\n      let validatedBpm = emptyNumber;\n      if (data.comment) {\n        if (data.comment.text) {\n          validatedTags = data.comment.text.trim();\n        }\n      }\n      if (data.bpm) {\n        validatedBpm = this.helper.getParsedIntSimple(data.bpm.trim(), emptyNumber);\n      }\n      const musicObject = {\n        dir: file,\n        simple: {\n          title: data.title ? data.title.trim() : emptyString,\n          artist: data.artist ? data.artist.trim() : emptyString,\n          album: data.album ? data.album.trim() : emptyString,\n          composer: data.composer ? data.composer.trim() : emptyString,\n          genre: data.genre ? data.genre.trim() : emptyString,\n          year: data.year ? data.year.trim() : emptyString,\n          bpm: validatedBpm,\n          initialKey: data.initialKey ? data.initialKey.trim() : emptyString,\n          tags: validatedTags\n        },\n        tags: this.getTagsFromData(data),\n        metadata: data\n      };\n      return musicObject;\n    }\n    // name: string; // is also id, if duplicate, it should just pick 1?\n    // dir: string;\n    // newDir: string;\n    // tagObjects: TagObject[];\n    // isMissingTags: boolean;\n    // isMoved: boolean;\n    // isSelected: boolean;\n    // isClicked: boolean;\n    // name: string; // actual value\n    // group: string; // suggestion object\n    // metaDataGroup: string; // title, so on, comment\n    getMetadataObject(o, suggestionsObject) {\n      const data = {\n        name: o.file ? this.getFileName(o.file) : '',\n        dir: o.file ? o.file : '',\n        newDir: o.file ? o.file : '',\n        tagObjects: this.getTagObjects(o.data, suggestionsObject),\n        isMissingTags: false,\n        isMoved: false,\n        isSelected: false,\n        isClicked: false\n      };\n      return data;\n    }\n    getMetadataObjectSimple(o, suggestionsObject) {\n      const data = {\n        name: o.file ? this.getFileName(o.file) : '',\n        dir: o.file ? o.file : '',\n        newDir: o.file ? o.file : '',\n        tagObjects: this.getTagObjectsSimple(o.data, suggestionsObject),\n        isMissingTags: false,\n        isMoved: false,\n        isSelected: false,\n        isClicked: false\n      };\n      return data;\n    }\n    getMetadataObjects(result, suggestionsObject) {\n      const all = [];\n      for (const row of result) {\n        const m = this.getMetadataObject(row, suggestionsObject);\n        all.push(m);\n      }\n      return all;\n    }\n    getMetadataObjectsSimple(result, suggestionsObject) {\n      const all = [];\n      for (const row of result) {\n        const m = this.getMetadataObjectSimple(row, suggestionsObject);\n        all.push(m);\n      }\n      return all;\n    }\n    // TODO: process tags flow last array item is file\n    getMetadataMatrix(result, suggestionsObject) {\n      const suggestionHeaders = Object.keys(suggestionsObject);\n      suggestionHeaders.push('other'); // some tags might not be from suggestions\n      const simpleHeaders = ['title', 'artist', 'album', 'genre', 'bpm', 'initialKey'];\n      const allHeaders = simpleHeaders.concat(suggestionHeaders);\n      allHeaders.push('dir');\n      const all = [];\n      for (const row of result) {\n        const arr = this.getTagObjectsSimple(row.data, suggestionsObject);\n        arr.push(row.file); // last item is file\n        all.push(arr);\n      }\n      return [allHeaders, all];\n    }\n    getTagObjects(o, suggestionsObject) {\n      // simple\n      const title = o.title ? o.title : '';\n      const artist = o.artist ? o.artist : '';\n      const album = o.album ? o.album : '';\n      const genre = o.genre ? o.genre : '';\n      const bpm = o.bpm ? o.bpm : '';\n      const initialKey = o.initialKey ? o.initialKey : '';\n      // comment\n      let commentAsArr = [];\n      if (o.comment) {\n        commentAsArr = o.comment.text ? this.getMetadataCommentAsArray(o.comment.text) : [];\n      }\n      const suggestionHeaders = Object.keys(suggestionsObject);\n      suggestionHeaders.push('other'); // some tags might not be from suggestions\n      const simpleHeaders = ['title', 'artist', 'album', 'genre', 'bpm', 'initialKey'];\n      const allHeaders = simpleHeaders.concat(suggestionHeaders);\n      const simpleValues = [title, artist, album, genre, bpm, initialKey];\n      const suggestionValues = this.getSuggestionValues(commentAsArr, suggestionsObject, suggestionHeaders);\n      const allValues = simpleValues.concat(suggestionValues);\n      const arr = [];\n      for (let i = 0; i < allHeaders.length; i++) {\n        const header = allHeaders[i];\n        const value = allValues[i];\n        const tagObject = {\n          name: value,\n          group: header\n        };\n        arr.push(tagObject);\n      }\n      return arr;\n    }\n    getTagObjectsSimple(o, suggestionsObject) {\n      // simple\n      const title = o.title ? o.title : '';\n      const artist = o.artist ? o.artist : '';\n      const album = o.album ? o.album : '';\n      const genre = o.genre ? o.genre : '';\n      const bpm = o.bpm ? o.bpm : '';\n      const initialKey = o.initialKey ? o.initialKey : '';\n      // comment\n      let commentAsArr = [];\n      if (o.comment) {\n        commentAsArr = o.comment.text ? this.getMetadataCommentAsArray(o.comment.text) : [];\n      }\n      const suggestionHeaders = Object.keys(suggestionsObject);\n      const simpleValues = [title, artist, album, genre, bpm, initialKey];\n      const suggestionValues = this.getSuggestionValues(commentAsArr, suggestionsObject, suggestionHeaders);\n      return simpleValues.concat(suggestionValues);\n    }\n    getTagObjectsSimpleOld(o, suggestionsObject) {\n      // simple\n      const title = o.title ? o.title : '';\n      const artist = o.artist ? o.artist : '';\n      const album = o.album ? o.album : '';\n      const genre = o.genre ? o.genre : '';\n      const bpm = o.bpm ? o.bpm : '';\n      const initialKey = o.initialKey ? o.initialKey : '';\n      // comment\n      let commentAsArr = [];\n      if (o.comment) {\n        commentAsArr = o.comment.text ? this.getMetadataCommentAsArray(o.comment.text) : [];\n      }\n      const suggestionHeaders = Object.keys(suggestionsObject);\n      const simpleHeaders = ['title', 'artist', 'album', 'genre', 'bpm', 'initialKey'];\n      const allHeaders = simpleHeaders.concat(suggestionHeaders);\n      const simpleValues = [title, artist, album, genre, bpm, initialKey];\n      const suggestionValues = this.getSuggestionValues(commentAsArr, suggestionsObject, suggestionHeaders);\n      const allValues = simpleValues.concat(suggestionValues);\n      const arr = [];\n      for (let i = 0; i < allHeaders.length; i++) {\n        arr.push(allValues[i]);\n      }\n      return arr;\n    }\n    // TODO: process tags flow extra tags in same group are joined by ' ', so that table can sort it properly\n    getSuggestionValues(commentAsArr, suggestionsObject, suggestionHeaders) {\n      const all = [];\n      let suggestionsAll = [];\n      for (const key of suggestionHeaders) {\n        const values = suggestionsObject[key];\n        const selected = [];\n        suggestionsAll = suggestionsAll.concat(values);\n        for (const val of values) {\n          if (this.helper.isInArray(val, commentAsArr)) {\n            selected.push(val);\n          }\n        }\n        all.push(selected.join(this.TABLE_EXTRA_VALUE_SPLITTER));\n      }\n      const otherValues = [];\n      for (const val of commentAsArr) {\n        if (!this.helper.isInArray(val, suggestionsAll)) {\n          otherValues.push(val);\n        }\n      }\n      all.push(otherValues.join(this.TABLE_EXTRA_VALUE_SPLITTER));\n      return all;\n    }\n    // TODO:  process tags flow extra tags in same group are joined by ' ', so that table can sort it properly\n    getTagsFromMatrixRow(matrixRow) {\n      const arr = [];\n      if (matrixRow) {\n        if (matrixRow.length > 0) {\n          const tags = matrixRow.slice(6, matrixRow.length - 1);\n          const rearrangedArray = tags.join(this.TABLE_EXTRA_VALUE_SPLITTER).split(this.TABLE_EXTRA_VALUE_SPLITTER); // some values are joined with space, because of the matrix to be sortable\n          return rearrangedArray.filter(res => {\n            if (res) {\n              return true;\n            } else {\n              return false;\n            }\n          });\n        }\n      }\n      return arr;\n    }\n    showPopup(titleIn, message, codeIn) {\n      const dialogMessage = {\n        title: titleIn,\n        list: [{\n          title: titleIn,\n          content: message\n        }],\n        code: codeIn\n      };\n      this.dialog.openDialog(dialogMessage).then(reply => {});\n    }\n    // must be in the same order (objects and searchstrings)\n    getFilteredMusic(musicSortables, lessThan) {\n      return musicSortables.filter(item => {\n        for (const val of this.searchStringsArray) {\n          const searchColumn = val.column;\n          const b = val.search;\n          if (b) {\n            const a = item.simple[searchColumn];\n            const match = this.isMatch(a, b, lessThan);\n            if (searchColumn === 'tags') {\n              if (a) {\n                const tags = b.split(',');\n                for (const tag of tags) {\n                  const matchTag = this.isMatch(a, tag, lessThan);\n                  if (!matchTag) {\n                    return false;\n                  }\n                }\n              }\n            } else {\n              if (!match) {\n                return false;\n              }\n            }\n          }\n        }\n        return true;\n      });\n    }\n    isMatch(a, b, lessThan) {\n      if (!isNaN(a)) {\n        const bParsed = this.helper.getParsedIntSimple(b, 0);\n        if (lessThan) {\n          return a < bParsed;\n        } else {\n          return bParsed < a;\n        }\n      }\n      return a.toLowerCase().indexOf(b + ''.toLowerCase()) > -1;\n    }\n    handleSortMusic(sort, arr) {\n      return arr.sort((a, b) => {\n        const isAsc = sort.direction === 'asc';\n        switch (sort.active) {\n          case 'title':\n            return this.compare(a.simple.title, b.simple.title, isAsc);\n          case 'artist':\n            return this.compare(a.simple.artist, b.simple.artist, isAsc);\n          case 'album':\n            return this.compare(a.simple.album, b.simple.album, isAsc);\n          case 'composer':\n            return this.compare(a.simple.composer, b.simple.composer, isAsc);\n          case 'genre':\n            return this.compare(a.simple.genre, b.simple.genre, isAsc);\n          case 'year':\n            return this.compare(a.simple.year, b.simple.year, isAsc);\n          case 'bpm':\n            return this.compare(a.simple.bpm, b.simple.bpm, isAsc);\n          case 'initialKey':\n            return this.compare(a.simple.initialKey, b.simple.initialKey, isAsc);\n          case 'tags':\n            return this.compare(a.simple.tags, b.simple.tags, isAsc);\n          default:\n            return 0;\n        }\n      });\n    }\n    compare(a, b, isAsc) {\n      return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n    }\n    getFileName(filePath) {\n      return this.communicator.getFileName(filePath);\n    }\n    // max should be something like file array to load length\n    setFeedback(isLoading, message) {\n      if (message) {\n        this.feedbackCounter++;\n        this.updateProgress(this.feedbackCounter, this.maxFeedbackLimit);\n        if (typeof message === 'string') {\n          this.feedbackSubject.next(message);\n        } else {\n          this.feedbackSubject.next(JSON.stringify(message));\n        }\n        this.progressSubject.next(this.progress);\n      }\n    }\n    updateProgress(count, max) {\n      if (max > 0) {\n        const percentageProgress = count * 100 / max;\n        this.progress = Math.round(percentageProgress);\n      }\n    }\n    setMaxForFeedback(max) {\n      this.progress = 0;\n      this.feedbackCounter = 0;\n      this.maxFeedbackLimit = max;\n    }\n    setMessage(message) {\n      this.commonMessageSubject.next(message);\n    }\n    getMessageSubscription() {\n      return this.commonMessageObservable;\n    }\n    getFeedbackSubscription() {\n      return this.feedbackObservable;\n    }\n    getProgressSubscription() {\n      return this.progressObservable;\n    }\n    setUnsubscribeTidyWithElectron(subscriptions) {\n      if (subscriptions) {\n        for (const subscription of subscriptions) {\n          if (subscription) {\n            try {\n              subscription.unsubscribe();\n            } catch (error) {\n              console.log('Failed to unsubscribe electron.');\n              console.log(error);\n            }\n          }\n        }\n      }\n      this.communicator.unsubscribeElectron();\n    }\n    setUnsubscribeTidy(subscriptions) {\n      if (subscriptions) {\n        for (const subscription of subscriptions) {\n          if (subscription) {\n            try {\n              subscription.unsubscribe();\n            } catch (error) {\n              console.log('Failed to unsubscribe.');\n              console.log(error);\n            }\n          }\n        }\n      }\n    }\n    /**\n     * accepts array of tags\n     * returns object to send to electron\n     */\n    getTagsToRequest(filePath, resultsArray) {\n      const tags = this.getTagsToMetadata(resultsArray);\n      const options = {\n        key: 'setMusicData',\n        dir: filePath,\n        tagsObject: tags\n      };\n      return options;\n    }\n    setSuggestionsFromTrack(metadataObject) {\n      const arr = this.helper.getValuesFromKeys(metadataObject, this.metadataKeys);\n      const uniques = this.helper.getOnlyUnique(arr);\n      const trimmed = this.helper.getTrimmedArray(uniques);\n      const lowered = this.helper.getLowerCaseArray(trimmed);\n      return lowered;\n    }\n    getTagsToMetadata(resultsArray) {\n      if (resultsArray) {\n        if (resultsArray.length) {\n          const trimedArr = resultsArray.map(str => str.trim().toLowerCase());\n          const tagString = trimedArr.join(',');\n          const updatedComment = {\n            language: 'eng',\n            shortText: '',\n            text: tagString\n          };\n          // library requires top object // I didn't realize and ruined some files :D\n          // update just edits tags added, write overwrites and deletes the rest\n          const tags = {\n            COMM: updatedComment,\n            comment: updatedComment\n          };\n          return tags;\n        }\n      }\n      return '';\n    }\n    getTagsFromData(data) {\n      if (data) {\n        if (data.comment) {\n          if (data.comment.text) {\n            return this.getMetadataCommentAsArray(data.comment.text);\n          }\n        }\n      }\n      return [];\n    }\n    getMetadataCommentAsArray(comment) {\n      if (comment) {\n        const c = comment.toString();\n        let arr = c.split(',');\n        if (arr) {\n          arr = this.helper.getLowerCaseArray(arr);\n          return this.helper.getTrimmedArray(arr);\n        }\n      }\n      return [''];\n    }\n    // TODO: useful: transform object of objects to array of objects\n    getSuggestionsAsArray(suggestionsFromFile) {\n      const keys = Object.keys(suggestionsFromFile);\n      const arr = new Array(keys.length);\n      Object.keys(suggestionsFromFile).forEach(key => {\n        const val = suggestionsFromFile[key];\n        arr[val.i] = {\n          name: key,\n          color: val.color,\n          group: val.group\n        };\n      });\n      return arr;\n    }\n    // TODO: useful: transform object of objects to matrix array of objects\n    getSuggestionsAsMatrix(suggestionsFromFile) {\n      const arr = this.getSuggestionsAsArray(suggestionsFromFile);\n      let currentGroup = arr[0].group;\n      const matrix = [];\n      let currentRow = [];\n      for (const suggestionObj of arr) {\n        const group = suggestionObj.group;\n        if (currentGroup !== group) {\n          matrix.push({\n            title: currentGroup,\n            value: currentRow\n          });\n          currentGroup = group;\n          currentRow = [];\n        }\n        currentRow.push(suggestionObj);\n      }\n      // last push\n      matrix.push({\n        title: currentGroup,\n        value: currentRow\n      });\n      return matrix;\n    }\n    // TODO: useful: transform object of objects to matrix array of objects\n    getSuggestionsAsObject(suggestionsFromFile) {\n      const arr = this.getSuggestionsAsArray(suggestionsFromFile);\n      let currentGroup = arr[0].group;\n      const matrix = {};\n      let currentRow = [];\n      for (const suggestionObj of arr) {\n        const group = suggestionObj.group;\n        if (currentGroup !== group) {\n          matrix[currentGroup] = currentRow;\n          currentGroup = group;\n          currentRow = [];\n        }\n        currentRow.push(suggestionObj.name);\n      }\n      // last push\n      matrix[currentGroup] = currentRow;\n      return matrix;\n    }\n    static #_ = this.ɵfac = function DataProcessorService_Factory(t) {\n      return new (t || DataProcessorService)(i0.ɵɵinject(i1.PopupService), i0.ɵɵinject(i2.HelperService), i0.ɵɵinject(i3.CommunicatorElectronService));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: DataProcessorService,\n      factory: DataProcessorService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DataProcessorService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}